# Docker overview

## Особенности

Благодаря контейнеризации, разработчики больше не задумываются о том, в какой среде будет функционировать их 
приложение и будут ли доступны в этой среде необходимые для запуска инструменты и зависимости. Достаточно упаковать 
все нужные опции и зависимости в контейнер, после чего его можно будет запускать почти на любой машине под управлением 
любой ОС: Windows, Linux или MacOS. То есть Docker отделяет само приложение от инфраструктуры.

## Основные компоненты Docker

### Dockerfile

Текстовый файл с последовательностью инструкций для создания образа. Файл создаётся по принципу: 
«Одна строка — одна команда».

### Image

Образ — это неизменяемый файл, основа, из которой можно неограниченное количество раз развернуть контейнер.

### Container

Запущенное приложение, которое развернули из образа.

### Registry

Служба в Docker, выполняющая функции репозитория. Позволяет следить за версиями образов, создавать 
приватные репозитории.

### Docker Hub

Популярный публичный репозиторий. По умолчанию используется в Docker.

### Daemon

Фоновая служба на хосте, которая отвечает за создание, запуск и уничтожение контейнеров. Любое взаимодействие 
с контейнером проходит через него.

### Client

Утилита командной строки в Docker для управления демоном.

### Volumes

Тома для постоянного хранения информации. По сути — подключенные извне хранилища. По умолчанию в Docker папки 
хранилищ создаются на хост-машине.

## Как устроен Docker-образ

Самой первой командой при создании образа является указание базового образа. **Базовый образ** уже содержит 
в себе произвольный набор инструкций и команд, на основе которых будет выстраиваться «наследуемый» образ.

> Базовый образ, как и последующие слои, доступен только для чтения.

На базовый образ накладываются один за другим новые слои, каждый из которых представляет собой одну из 
команд: `FROM`, `RUN`, `COPY`, `ADD`. Каждый новый слой, по сути, тоже является образом. И получается, 
что финальный образ — это объединение всех слоёв в один.

Каждый слой образа сохраняется, чтобы к нему при необходимости можно было быстро откатиться. Даже при изменении 
какой-то команды в докер-файле пересборка начинается только с изменённого слоя. Такой подход значительно ускоряет 
время сборок.

### Контейнер

Если образ доступен только чтения, то контейнер представляет собой тот же образ, но с ещё одним слоем сверху — 
с возможностью записи. После уничтожения контейнера верхний слой и содержащиеся в нём данные пропадают. 
И в случае необходимости создаётся новый, чистый контейнер на основе имеющегося образа.

![Docker. Image + container](./assets/Docker.%20Image%20+%20container.png)

В любом образе Docker хранится Docker manifest. Это JSON-файл, содержащий информацию об образе: ссылки на каждый 
существующий слой, данные об их размере, хеш, а также сведения о платформе, на которой он будет работать.

## Инструкции Dockerfile

1. `FROM` — задаёт базовый образ.
2. `LABEL` — описывает метаданные, например, сведения о том, кто создал и поддерживает образ.
3. `ARG` — задаёт переменные, существующие во время сборки образа.
4. `ENV` — устанавливает постоянные переменные окружения.
5. `RUN` — выполняет команду и создаёт слой образа, используется в основном для установки пакетов в контейнер.
6. `ADD` — копирует файлы и папки в контейнер. Может распаковывать tar-файлы.
7. `COPY` — копирует файлы и папки в контейнер.
8. `WORKDIR` — задаёт рабочую директорию, в которой будут выполняться последующие команды.
9. `CMD` — описывает команду с аргументами, которую нужно выполнить при запуске контейнера. Аргументы могут быть 
переопределены при запуске. В файле может присутствовать лишь одна команда `CMD`.
10. `ENTRYPOINT` — предоставляет команду с аргументами, которая вызывается во время выполнения контейнера. 
Аргументы не переопределяются.
11. `EXPOSE` — показывает, какой порт пробрасывать из контейнера.
12. `VOLUME` — создаёт точку монтирования для работы с постоянным хранилищем, то есть «синхронизирует» 
конкретную папку внутри контейнера с папкой во внешней ОС.

### COPY vs ADD

Разница между **COPY** и **ADD** заключается в том, что первая директива просто копирует файлы, тогда как вторая 
умеет не только копировать, но и скачивать файлы в указанную директорию по `URL`. Кроме того, если команде **ADD** 
указать архив, то файлы при добавлении этого архива будут распакованы. Поэтому существует простое правило: **если мы 
не знаем точно, для чего нам нужен ADD, значит, используем COPY**.

### ENTRYPOINT vs CMD

Разница между директивами **ENTRYPOINT** и **CMD** заключается в том, что первая используется для постоянного 
исполнения команды при запуске docker-контейнера, а вторая позволяет эту команду в случае надобности заменить 
указанной в качестве параметра (например: `docker run -t -i bash`).

```dockerfile
FROM debian:wheezy
ENTRYPOINT ["/bin/ping"]
CMD ["localhost"]
```

Запуск без замены команды:

```bash
$ docker run -it test
PING localhost (127.0.0.1): 48 data bytes
56 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.096 ms
56 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.088 ms
56 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.088 ms
^C--- localhost ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.088/0.091/0.096/0.000 ms
```

Запуск с заменой:

```bash
$ docker run -it test google.com
PING google.com (173.194.45.70): 48 data bytes
56 bytes from 173.194.45.70: icmp_seq=0 ttl=55 time=32.583 ms
56 bytes from 173.194.45.70: icmp_seq=2 ttl=55 time=30.327 ms
56 bytes from 173.194.45.70: icmp_seq=4 ttl=55 time=46.379 ms
^C--- google.com ping statistics ---
5 packets transmitted, 3 packets received, 40% packet loss
round-trip min/avg/max/stddev = 30.327/36.430/46.379/7.095 ms
```

